// Концепции
Концепции:
1. Инкапсуляция
2. Наследование
3. Полиморфизм
4. Композиция

// Процедурное программирование vs Объектно-ориентированное программирование
Все, что нас окружает - это объекты
	Пример: 
	Человек - имеет свои атрибуты и поведение
			атрибуты: цвет глаз, возраст, вес
			поведение: ходьба, умение разговаривать, умение дышать
***Объект  - это сущность, одновременно содержащая данные и поведения.

При объектно-ориентированном программировании атрибуты и поведения размещаются в рамках одного объекта, в то время как
при процедурном или структурном проектировании атрибуты и поведения обычно разделяются.

***Скрытие данных : В объектно-ориентированной терминологии данные называются атрибутами, а поведения - методами.
Ограничение доступа к определенным атрибутам и/или методам называется скрытием данных.

	Пример:  Калькулятор - при определении суммы на калькуляторе используется
только интерфейс. В калькулятор заложен метод для вычисления суммы, который
вызывается, когда нажимается соотвествующая кнопка. После этого приходит правильный ответ, но как он был получен мы не знаем.


Процедурное программирование: данные той или иной системы обычно отделяются от
операций, используемых для манипулирования ими. Например, если необходимо
передать информацию по сети, то будут отправлены только релевантные данные с
расчетом на то, что программа на другом конце сетевой магистрали будет знать,
что с ними делать.

Объектно-ориентированное программирование: и данные, и операции(код), используемые для манипулирования ими, инкапсулируются в одном объекте.
	При перемещении объекта по сети он передается целиком, включая данные и поведение.


Объекты - это строительные блоки объектно-ориентированных программ.
Данные объектов - состояние объекта(атрибуты).
	Пример: атрибуты работника (SocialSecurityNumber, Gender, DateOfBirth)
Поведения объектов - что объект может сделать( в процедурных языках определяется процедурами, функциями и подпрограммами) (методы).
	Пример: методы работника (setGender() getGender() - для установки и получения пола).

***Геттеры и сеттеры: Концепция геттеров и сеттеров поддерживает концепцию
скрытия данных. Поскольку объекты не должны напрямую манипулировать данными,
содержащимися в одном из объектов, геттеры и сеттеры обеспечивают управляемый
доступ к данным объекта. Геттеры и сеттеры иногда называют методами доступа и
методами-модификаторами соотвественно.

	Пример: объект Payroll содержит метод с именем calculatePay(), который используется для вычисления суммы з/п каждого работника
			объекту потребуется номер социального страхования каждого работника
			объект Payroll вызовет метод getSecurityNumber() объекта Employee


// Класс
Класс - это "чертеж" объекта
	Пример: велосепед определенного человека - это объект. Однако, для того, чтобы построить этот велосипед, кто-то сначала подготовил чертежи, по которым он затем был изготовлен.
	public class Person {
		// Атрибуты
		private String name;
		private String address;

		// Методы
		public String getName(){
			return name;
		}

		public void setName(String n){
			name = n;
		}

		public String getAddress(){
			return address;
		}

		public void setAddress(String adr){
			address = adr;
		}
	}

***Обозначение доступа: Когда типа дыннх или метод определен как public, у других объектов будет к нему прямой доступ.
	Когда тип данных или метод определен как private, только конкретный объект сможет получить к нему доступ.
	Protected разрешает доступ с использованием связынных объектов.


// Сообщения
Сообщения - это механизм коммуникации между объектами.
	Пример: Когда объект А вызывает метод объекта В, объект А отправляет сообщение объекту В.
			Ответ объекта В определяется его возвращаемым значением.


// Интерфейсы 
Интерфейс - представляет собой основные средства коммуникации между объектами

*** Закрытые данные: Для того чтобы скрытие данных произошло,
все атрибуты должны быть объявлены как private. 
	Поэтому атрибуты никогда не
являются частью интерфейсов. Частью интерфейсов классов могут быть только
открытые методы. 
	Объявление атрибуты как public нарушает концепцию скрытия
данных.


// Реализации
Все, определенное как private окажется недоступно пользователям и будет считаться частью внутренней реализации классов.

	Пример интерфейс/реализация: Точтеру для работы требуется электричество.
	Чтобы обеспечить подачу электричества, нужно вставить вилку шнура тостера в электрическую розетку, которая является интерфейсом.
	Для того, чтобы получить требуемое электричество, тостеру нужно лишь "реализовать" шнур, который соотвествует техническим характеристикам электрической розетки
	Для тостера не имеет значения, что фактиченской реализацией является электростанция, работающая на угле. 

	public class IntSquare {
		// Закрытый атрибут
		private int squareValue;

		// Открытый интерфейс
		public int getSquare(int value){
			SquareValue = calculateSquare(value);
			return squareValue;
		}

		// Закрытая реализация
		private int calculateSquare(int value){
			return value*value;
		}
	} 

	Единственный метод, доступный для пользователя, является открытый метод getSquare()

//********** Наследование
Основное назначение наследование - возможность повторного использования кода.
	Пример: есть класс Dog и Cat, каждый из которых будет содержать атрибут eyeColor
			Атрибут можно перенести в класс Mammal, а класс Dog и Cat будут наследовать от класса Mammal


// Суперкласс и подклассы
Суперкласс, или родительский класс(иногла базовый), содержит все атрибуты и поведения, общие для классов, которые наследуют от него.(Mammal)
Подкласс, или дочерний класс(иногда производный), представляет собой расширение суперкласса.(Dog, Cat)


// Абстрагирование
Дочерние классы могут становиться родительскими для других классов. 
	Пример: Потребуется создать классы для персидских, сиамских кошек
			Получается что классы будут содержать атрибуты и методы класса Mammal и Cat


// Отношение "является экземпляром"
Пример: Cicle, Square, Star наследуют от Shape


// Полиморфизм
	Полиморфизм - это греческое слово, обозначающее множественность форм.

	public abstract class Shape{
		private double area;

		public abstract double getArea();
	}
	// Когда методы определяются как abstract, подкласс должен обеспечивать реализацию для этого метода

	// Класс Cicle наследуется от Shape

	public class Cicle extends Shape{
		double radius;

		public Cicle(double r){
			radius  = r;
		}

		public double getArea(){
			area = 3.14*(radius*radius);
			return(area);
		}
	} 

Конструктор - если имя метода оказывается аналогичными имени класса и при этом не предусматривает возвращаемого типа
	
	public class Rectangle extends Shape {
		double length;
		double width;

		public Rectangle(double l, double w){
			length = 1;
			width = w;
		}

		public double getArea(){
			area = length*width;
			return (area);
		}
	}

	Если подкласс наследует абстрактный метод от суперкласса, то он должен обеспечить конкретную реализацию этого метода, иначе он сам будет абстрактным классом

// Стек
*** Стек  - это структура данных, представляющих собой систему "последним поступил - первым ушел".


// Композиция
	Пример: Системный блок компьютера содержит - жесткий диск 
			Таким образом, объекты зачастую формируются или состояни из других объектов


// Абстрагирование
Наследование позволяет одному классу наследовать от другого, поэтому мы можем абстрагировать атрибуты и поведения для общих классов


// Отношения "Содержит как часть"
Создавая двигатель отдельно, мы сможем использовать его в разных автомобилях


Инкапсуляция - Один объект будет содержать как свои данные, так и поведения, и сможет скрыть то, что ему потребуется, от других объектов.
Наследование - Класс может наследовать от другого класса и пользовать преимущества атрибутов и методов, определяемых супрклассом.
Полиморфизм - Означает, что схожие объекты способны по-разному отвечать на одно и то же сообщение. Например, у вас может быть система с множеством фигур.
	Однако круг, квадрат и звезда рисуются по-разному. Используя полиморфизм, вы можете отправить одно и то же сообщение(например Draw) объектам, на каждый из которых возлагается обязанность по рисованию соответствующей фигуры
Композиция - Означает, что обхект формируется из других объектов.


 //Разница между интерфейсом и реализацией
 	Пример: автомобиль - включает такие компоненты как руль, педаль газа, педаль тормоза и переключатель зажигания
 			Когда речь идет об управлении автомобилем, для большинства людей главным является то, как он заводится, разгоняется, останавливается
 			Реализация, чем по сути является то, чего вы не видите, мало интересует среднестатистического водителя.
 			Однако любой водитель узнает руль и будет в курсе как его использовать поскольку это общий интерфейс.

 			Двигатель является частью реализации, а руль - частью интерфейса.
 			Изменения в реализации не должны оказывать влияение на водителя, а то время как изменения в интерфейсе могут это сделать

Интерфейс - услуги, предоставляемые конечным пользователям (в идеале, только те, которые им необходимы)
Реализация - реализация скрыта от пользователей. Изменения в реализации не должны требовать внесения изменений в пользовательский код

***Минимальный интерфейс: Один из способов, пусть даже экстремальных, определить минимальный интерфейс заключается в том, чтобы изначально не предоставлять пользователю никаких открытых интерфейсов
	Добавлять интерфейсы только тогда, когда они запрашиваются

***Постоянство объектов: Относится к концепции сохранения состояния того или иного объекта для того, чтобы его можно было восстановить и использовать позднее. 
	Объект, не являющийся постоянным, по сути "умирает", когда оказывается вне области видимости


// Абстрактное мышление
Для того, чтобы класс можно было использовать повторно
	Пример: Такси - 
		Абстрактно: "Отвезите меня в аэропорт"
		Конкретно: "Поверните направо, затем направо, затем налево, затем направо, затем налево"

1. Определение объектов (таксист и клиент)
2. Поведение объектов 
3. Ограничения, налагаемые средой
4. Определение открытых интерфейсов
5. Определение реализации


// Конструкторы
	Вызов конструктора осуществляется при создании нового объекта
	Внутри конструктора обычно происходит: инициализация выделенной памяти при обнаружении ключевого слова new
										   код внутри конструктора должен задать для нового объекта его начальное, стабильное, надежное состояние
*** Обеспечение конструкторы: Общее правило заключается в том, что вы должны всегда обеспечивать конструктор, даже если не планируете что-либо делать внутри него.
	Вы можете предусмотреть констуктор, в котором ничего нет, а затем добавить в него что-то.

// Перегрузка методов
Позволяет снова и снова использовать один и тот же метод, если его подпись каждый раз отличается
	Пример: public void getCab();

			// другой список параметров
			public void getCab(String cabbieName);

1. Внутри конструктора происходит вызов констуктора суперкласса соотвествующего класса. Если явного вызова констурктора суперкласса нет, то автоматически вызывается конструктор по умолчанию.
2. Инициализируется каждый атрибут класса объекта. Эти атрибуты являются частью определения класса, а не атрибутами внутри конструктора или любого другого метода(локальные переменные).
3. Выполняется остальная часть кода внутри конструктора.


// Область видимости
Экземпляры множественных объектов могут создаваться на основе одного класса.Каждый из этих объектов будет обладать уникальным идентификатором и состоянием.
Однако, если некоторые атрибуты и методы объявлены соотвествующим образом, они могут совместно использоваться всеми объектами, экземпляры которых созданы на основе одного и того же класса

Типы атрибутов: 
	- локальные
	- атрибуты объектов
	- атрибуты классов

// Локальные атрибуты
Принадлежат определенному методу
public class Number{
	public method1(){
		int count;
	}
	public method2(){

	}
}
method1 содержит локальную переменную count. Она доступна только внутри метода mwthod1


// Атрибуты объектов
public class Number{
	int count; // доступ к переменной имеется у обоих : method1 method2

	public method1(){
		count = 1;
	}

	public method2(){
		count = 2;
	}
}

// Атрибуты классов
public class Number{
	static int count;

	public method1(){

	}
}

атрибуту count выделяется один блок памяти для всех объектов, экземпляры которых будут созданы на основе класса
У каждого класса будет единственная копия, совместно используемая всеми объектами этого класса.


// *** Анатомия класса

1. Имя класса - Имя должно быть описательным. Оно обеспечивает информацию о том, что класс делает и как взаимодействует в рамках более крупных систем
2. Атрибуты - Представляют состояние определенного объекта, в них содержится информацию об этом объекте
3. Конструкторы - если реализации конструктора нет, то реализация конструктора предоставляется системой
4. Комментарии
5. Методы доступа 
	public void setName(String iName){
		name = iName;
	}

	public Stirng getName(){
		return name;
	}
***Статические атрибуты: Если атрибут является статическим, а класс обеспечивает для него сеттер, то любой объект, вызывающий этот сеттер, будет изменять единственную копию.
	Таким образом значение этого атрибута изменится для всех объектов
6. Методы открытых интерфейсов - методы public
7. Методы закрытых реализаций - методы private


// *** Проектирование классов
1. Определение открытого интерфейса
	- Минимальный открытый интерфейс
	- Скрытие реализации
2. Проектирование надежных конструкторов
3. Внедрение обработки ошибок в класс
	- Документирование класса и использование комментариев
	- Создание объектов с прицелом на взаимодействие (почти ни один класс не существует в изоляции)
4. Проектирование с учетом повторного использования
	- Проектирование с учетом расширяемости
	- Делаем имена описательными
	- Абстрагирование непереносимого кода (изоляция непереносимого кода в его собственном классе или методе)
	- Обеспечение возможности осуществить копирование и сравнение
	- Сведение области видимости к минимуму
	- Класс должен отвечать за себя
5. Проектирование с учетом сопровождаемости
	- Тестирование интерфейса
6. Использование постоянства объектов
	Постоянство - это концепция сохранения состояния объекта

	* Система плоских файлов - сохранить объект в плоском файле, серилиализовав его.
	* Реляционная база данных - потребуется промежуточное программное обеспечение
	* Объектно-ориентированная база данных - может показаться наиболее эффективной, однако вся информация большинства компаний содержится в унаследованных системах


// Наследование & Композиция

Наследование 
	Суперкласс Dog: bark pant
	Дочерние классы: GoldenRetriever (retrievaSpeed: int, retrieves: void)

	Мы создали класс GoldenRetriever, на не пришлось делать того, что уже сделано, то есть переписывать bark & pant

	Дочерний класс: LhasaApso (guardEfficiency: int, guards: void)

	* При необходимости изменить bark или pant нам не надо будет изменять его во всех классах
	* Однако не все собаки одинакого лаят

	// Обобщение, конкретизация
	* По мере того, как мы спускаемся по дереву наследования, все становится более конкретным
	Суперкласс: Dog(pantRate: int, pant: void)
	Дочерние классы: BarkingDog(barkFrequency: int, bark: void) YodelingDog(yodelFrequency: int, yodels: void)

	BarkingDog - дочерние классы: LhasaApso (guardEfficiency: int, guards: void) GoldenRetriever (retrievaSpeed: int, retrieves: void)
	YodelingDog - дочерние классы: Basenji(huntEfficiency: int, hunts: void)

	* Лучший подход - выделение как можно большей общности

Композиция
	Когда определенный объект состоит из других объектов, которые включены как объектные поля, новый объект называется составным, агрегированным или обобщенным
	Car содержит как часть Engine, Stereo, Dour
		Engine содержит как часть Pistons, SparkPlugs
		Stereo содержит как часть Radio, Cassette
			Radio содержит как часть Tuner
		Door содержит как часть Handle

Наследование ослабляет инкапсуляцию
	Если от суперкласса будет унаследована реализация, которая затем подвергнется модификации, то такое изменение распространится по иерархии классов
При использовании наследования важно придерживаться строгого условия "является экземпляром"


// Полиморфизм
Считается одним из наиболее изящных вариантов использования наследования
	public abstract class Shape {
		public abstract void draw();
	}

	public class Cicle extends Shape{
		public void draw(){
			System.out.print("Я рисую круг")
		}
	}

	public class Rectangle extends Shape{
		public void draw(){
			System.out.print("Я рисую прямоугольник")
		}
	}

	public class Star extends Shape{
		public void draw(){
			System.out.print("Я рисую звезду")
		}
	}
	Конкретные классы сами несут отвественность за функцию рисования



// Абстрактные классы
 - это класс, содержащий один или несколько методов, которые не имеют какой-либо обеспеченной реализации.

// Интерфейсы
Интерфейс, в отличие от абстрактного класса, может не обеспечивать вообще никакой реализации
Любой класс, реализаующий интерфейс, должен обеспечивать реализацию всех методов.
	public interface Nameable{
		Strign getName();
		void setName(String aName);
	}

*** Наследование реализации и наследование определения: Наследование иногда называют наследованием реализации, а интерфейсы - наследованием определения.

// Отличие абстрактного класса и интерфейса
Классы в строгом наследовании должны быть связанными. 
	Пример: Собака является млекопитающим
Интерфейсы могут использоваться для классов, которые не являются связаннами.
Абстрактный класс представляет некоторую реализацию. 
Интерфейс никогда не обеспечивает реализации какого-либо рода - только поведение.
	Он определяет поведение, которое будет одинаковым во всех классах, между которыми, возможно, не окажется никакой связи. 

// Заключение контракта
Когда подкласс проектируется с намерением реализовать контракт, он должен обеспечивать реализацию нереализованных методов в родительском классе или интерфейсе.
Преимущество контракта - стандартизация соглашений по программированию
	Пример: 
			public interface Nameable{
				public String getName();
				public void setName(String aName);
			}

			public class Planet implements Nameable{

				String planetName;
				public String getName(){
					return planetName;
				}

				public void setName(String myName){
					planetName = myName;
				}
			}

			public class Car implements Nameable{

				String carName;
				public String getName(){
					return carName;
				}

				public void setName(String myName){
					carName = myName;
				}
			}
	У нас имеется стандартный интерфейс, мы использовали контракт для гарантии того, что дело будет обстоять именно так.


// *** Создание объектов и объектно-ориентированное проектирование
Поэтапное создание: 
1. Стабильно сложные системы обычно представлены в форме иерархии, где любая система состоит из более простых подсистем, каждая из которых тоже состоит из более простых подсистем
2. Стабильно сложные системы почти не поддаются декомпозиции
3. Стабильно сложные системы почти всегда состоят из подсистем лишь нескольких разных типов, упорядоченных в разных комбинациях
4. Стабильные сложные системы почти всегда развиваются из простых рабочих систем


// Типы композиции
Агрегации
		Car содержит как часть Engine, Stereo, Dour
		Engine содержит как часть Pistons, SparkPlugs
		Stereo содержит как часть Radio, Cassette
			Radio содержит как часть Tuner
		Door содержит как часть Handle

Ассоциации
*** Агрегация - это сложные объект, состоящий из других объектов.
	Ассоциация используется, когда одному объекту нужно, чтобы другой объект оказал ему услугу

// Кардинальность
Количество объектов, участвующих в ассоциации, с указанием того, является это участие обязательным или необязательным



